# Branch Prediction

#### The Branch Problem
- Control flow instructions (branchs) are frequent 
  - 15-25% of all instructions
- Problem: Next fetch address after a control-flow instruction is not determined after N cycles in a pipelines processor
  - N cycles: (minimum) branch resolution latency
- If we are fetchinig W instructions per cycle (I.E. if the pipeline is W wide)
  - A branch misprediction leads to N x W wasted instruction slots

#### The Branch Problem: Importance
Assume N = 20 (20 pipeline stages), W = 5 (5 wide fetch)
– Assume: 1 out of 5 instructions is a branch
– Assume: Each 5 instruction-block ends with a branch

How long does it take to fetch 500 instructions?
– 100% accuracy
  - 100 cycles (all instructions fetched on the correct path)
  - **No wasted work**; IPC = 500/100 = 5
– 99% accuracy
  - 100 (correct path) + 20 × 1 (wrong path) = 120 cycles
  - **20% extra instructions fetched**; IPC = 500/120 = 4.17; ~20% longer exec time
– 90% accuracy
  - 100 (correct path) + 20 × 10 (wrong path) = 300 cycles
  - **200% extra instructions fetched**; IPC = 500/300 = 1.67; ~2X longer exec time
– 60% accuracy
  - 100 (correct path) + 20 × 40 (wrong path) = 900 cycles
  - **800% extra instructions fetched**; IPC = 500/900 = 0.55; ~9X longer exec time
 
 #### Control Dependence
 Question: What should the fetch PC be in the next cycle?\
 Answer: The address of the next instruction
 
 All instructions are control dependent on previous ones
 
 If the fetched instruction is a non-control-flow instruction:
 - Next fetch PC is the address of the next-sequential instruction
 - Easy to determine if we know the size of the fetched instruction
 
 If the instruction that is fetched is a control-flow instruction:
 - How do we determine the next fetch PC?
 
 How do we even know whether or not the fetched instruction is a control-flow instruction?
 
 ## Overview
 - [Control-flow instruction types](#control-flow-instruction-types)
 - [Conditional Branch direction prediction]
  - Static branch prediction
  - Dynamic branch prediction
    - Last-time, bimodal
    - History-based
    - Interference: filtering, gshare, gskew
    - Hybrid
    - Further enhancements: loop, perceptron, hybrid history
- How to handle mispredictions?

### Control-Flow Instruction Types
|Type|Direction at fetch time|Number of possible next fetch addresses|When is next fetch address resolved|
|-|-|-|-|
|Conditional branch|Unknown|2|Execution (register dependent)|
|Unconditional branch|Always taken|1|Decode (PC + offset)|
|Call|Always taken|1|Decode (PC + offset)|
|Return|Always taken|Many|Execution (register dependent)|
|Indirect branch/call|Always taken|Many|Execution (register dependent)|

_Different branch types are handled differently_

