# Superscalar Execution

## Overview
- [Recap: Hazards in instruction pipelines](#recap-hazards-in-instruction-pipelines)
  - [Due to data dependences](#data-dependences)
  - [Due to control dependences](#hazard-due-to-control-dependence)
- From scalar, to superscalar, to out-of-order
  - Diversified pipeline
  - Superscalar pipeline
  - Out-of-order execution
- The out-of-order pipeline

## Recap: Hazards in instruction pipelines

### Instruction Pipeline
Instruction pipeline:
- `IF` Instruction Fetch
- `ID` Instruction Decode
- `OF` Operand Fetch
- `EX` Execute
- `MEM` Memory Read/Write
- `WB` Write Back = Completion = update architecture state

### Program dependences
3 types
- Data dependence through memory
- Data dependence through registers
- Control dependence

Not respecting a program dependence\
=> Hazard\
=> Should not happen!

### Data Dependences
- **Real dependence** = RAW (Read-After-Write)
- **Anti dependence** = WAR (Write-After-Read)
- **Output dependence** = WAW (Write-After-Write)

### Memory dependences
The MEM pipeline stage reads/writes to/from memory
All accessess to memory execute sequentially and in program order

### Register dependences
Hazards?
- Hazard due to WAW register dependence?\
  No, only WB trap writes, and does so sequentially and in program order
- Hazard due to WAR register dependence?\
  No, reading is dont in OF trap writing is done in WB trap
- Hazard dus to RAW register dependence?\
  **Yes**, may happen if an instruction reads an old value from the register file. (Because it hasn't been written yet, but we're already trying to read it)
  - Naive solution: **Pipeline Stall**: stall pipeline until the new value has been written back to the register file
  - Better solution: **Forwarding**: make forwarding paths in hardware (EX to EX, MEM to EX and WB to EX) that forward the new value to the execution trap
 
 ### Hazard due to control dependence
Problem: how do you know the next instruction to be fetched after fetching a control-flow instruction?

### Solution: Branch Prediction & Speculative execution
- Predict the targeet address of the branch
- Start (speculatively) executing instructions along the predicted path

### Upon a correct prediction
No penalty, 0 cycles lost

### Upon a misprecition
Incorrect prediction => Flush wrong-path instructions from pipeline and re-direct fetch

### Cost per mispredicted branch
Cost per mispredicted branch is proportional to pipeline depth (no. pipeline stages)

Example:
|pipeline-stage|x|x+1|x+2|x+3|x+4|x+5|
|-|-|-|-|-|-|-|
If a wrong prediction happends at x, it will only be noticed at x+4 (when it has left the EX trap), so all instructions that are now in the previous stages (IF, ID, OF, EX) need to be flushed. Since the execute stage is in the 4th traph, we have a penalty of 4 cycles.

### Iron Law of Performance (for single-threaded applications)**
**Execution time T = N x CPI x (1/f)**\
with `N the no.insns to execute`, `CPI the avg no. cycles per insn` and `f the clock frequency`

### Optimal pipeline depth
Deeper pipelines:
- Less logic per cycle
- Enables higher clock frequency f
- Leads to higher cost due to mispredictions -> higher CPI

Hence there exists an optimum depth that balances
- Amount of work done per cycle: IPC = 1/CPI
- Number of cycles per second: f

Also: dynamic power consumption increases with clock frequency! (P ~ f^3)\
-> yet another reason why not super-deep pipelines; see later

# From scalar, to superscalar, to out-of-order

