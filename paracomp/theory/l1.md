# Superscalar Execution

## Overview
- [Recap: Hazards in instruction pipelines](#recap-hazards-in-instruction-pipelines)
  - [due to data dependences](#data-dependences)
  - [due to control dependences](#hazard-due-to-control-dependence)
- From scalar, to superscalar, to out-of-order
  - Diversified pipeline
  - Superscalar pipeline
  - Out-of-order execution
- The out-of-order pipeline

## Recap: Hazards in instruction pipelines

### Instruction Pipeline
Instruction pipeline:
- `IF` Instruction Fetch
- `ID` Instruction Decode
- `OF` Operand Fetch
- `EX` Execute
- `MEM` Memory Read/Write
- `WB` Write Back = Completion = update architecture state

### Program dependences
3 types
- Data dependence through memory
- Data dependence through registers
- Control dependence

Not respecting a program dependence\
=> Hazard\
=> Should not happen!

### Data Dependences
- **Real dependence** = RAW (Read-After-Write)
- **Anti dependence** = WAR (Write-After-Read)
- **Output dependence** = WAW (Write-After-Write)

### Memory dependences
The MEM pipeline stage reads/writes to/from memory
All accessess to memory execute sequentially and in program order

### Register dependences
Hazards?
- Hazard due to WAW register dependence?\
  No, only WB trap writes, and does so sequentially and in program order
- Hazard due to WAR register dependence?\
  No, reading is dont in OF trap writing is done in WB trap
- Hazard dus to RAW register dependence?\
  **Yes**, may happen if an instruction reads an old value from the register file. (Because it hasn't been written yet, but we're already trying to read it)
  - Naive solution: **Pipeline Stall**: stall pipeline until the new value has been written back to the register file
  - Better solution: **Forwarding**: make forwarding paths in hardware (EX to EX, MEM to EX and WB to EX) that forward the new value to the execution trap
 
 ### Hazard due to control dependence
Problem: how do you know the next instruction to be fetched after fetching a control-flow instruction?
